import click
import json
import boto3
import botocore
from tools.get_ami_releases import GetECSAmisReleases
import subprocess
from utils import logger, stream_messages, tool_config
import logging
# Initialize models
model_id ='anthropic.claude-3-sonnet-20240229-v1:0' 
session = boto3.Session()
aws_region = 'us-west-2'

# Config to avoid timeouts when using long prompts
config = botocore.config.Config(
    read_timeout=1800,
    connect_timeout=1800,
    retries={"max_attempts": 0}
)
bedrock_client = session.client(service_name='bedrock-runtime', region_name=aws_region,config=config)


### CLI
@click.group()
@click.option('--verbose', help='Print detailed information in output besides the final report', is_flag=True, required=False, default=False)
def cli(verbose):
    if verbose:
        logger.setLevel(logging.INFO)
        logger.info("Logging level set to INFO")
    else:
        logger.setLevel(logging.WARNING)

@cli.command()  
@click.option('--project-directory', help="Project directory to execute terraform commands", required=True)
def eval(project_directory):
    # Getting the resources
    click.echo('Running terraform plan')
    cmd_result = subprocess.run(["terraform","plan","-out=plan.txt"],cwd=project_directory)
    if cmd_result.returncode != 0:
        click.echo('There was an error with the terraform plan command.')
        exit(cmd_result.returncode)
    click.echo('Converting plan to JSON')      
    cmd_result = subprocess.run(["terraform","show","-json",f"plan.txt"],stdout=subprocess.PIPE,cwd=project_directory)
    if cmd_result.returncode != 0:
        click.echo('There was an error with the "terraform show -json" command.')
        exit(cmd_result.returncode)
    
    t_plan_json = json.loads(cmd_result.stdout.decode().strip())

    click.echo('Evaluating plan using Amazon Bedrock Claude 3')   

    # Get modifications to be done
    prompt = """
    List the resources that will be created, modified or deleted in the following terraform plan using the following rules:
    1. Think step by step using the "thinking" json field
    2. For AMI changes, include the old and new AMI ID
    3. Use the following schema
    <schema>
            {
                "$id": "https://example.com/arrays.schema.json",
                "$schema": "https://json-schema.org/draft/2020-12/schema",
                "type": "object",
                "properties": {
                    "thinking": {
                        "type": "string",
                        "description": "Think step by step"
                    },
                    "resources": {
                        "type": "string",
                        "description": "A list of resources that will be created, modified or deleted"
                    }
                }
            }
    </schema>
    Here is an example of the output:
        <example>
        {
        "thinking": "To list the resources that will be created, modified or deleted, I will go through the terraform plan and look for the 'actions' field in each resource change. If the actions include 'create', 'update', or 'delete', I will add that resource to the list. For AMI changes, I will include the old and new AMI ID.",
        "resources": "The following resources will be modified: RESOURCES"
        }
        </example>
    Now, list the resources that will be created, modified or deleted in the following terraform plan"""
    prompt+=f""" 
    <terraform_plan>
    {t_plan_json["resource_changes"]}
    </terraform_plan>
    """
    messages  = [
            {
            "role": "user",
            "content": [
                    {
                    "text": prompt,
                    }
                ]
            }
        ]
    system_text = "You are an assistant that helps reading infrastructure changes from JSON objects generated by terraform"
    stop_reason, analysis_response  = stream_messages(
            bedrock_client, model_id, messages, system_text)
    
    analysis_response_text = json.loads(analysis_response['content'][0]['text'])['resources']

    # Evaluate AMIs per analysis
    prompt = """
        Find additional details of infrastructure changes using the following rules
        1. For Amazon machine image (AMI or image_id) modifications, compare the old AMI information against the new AMI, including linux kernel, docker and ecs agent using the GetECSAmisReleases function.
        2. Think step by step using "thinking" tags field
        3. Use the following schema. Skip the preamble:
        <output>
        <thinking></thinking>
        <result>## Current AMI ID
                        * AMI name:
                        * OS Architecture:
                        * OS Name:
                        * kernel:
                        * docker version:
                        * ECS agent:

                        ## New AMI ID
                        * AMI name:
                        * kernel:
                        * OS Architecture:
                        * OS Name:
                        * docker version:
                        * ECS agent:"</result>
        <output>
        Now, given the following analysis, compare any old with new AMIs:
        """
    prompt += f"""
        <analysis>{analysis_response_text}</analysis>
        """
    messages = [
            {
            "role": "user",
            "content": [
                    {
                    "text": prompt
                    }
                ]
            }
        ]
    
    stop_reason, response  = stream_messages(
            bedrock_client, model_id, messages, system_text, tool_config)
    
    # Add response to message history
    messages.append(response)

    # Check if there is an invoke function request from Claude
    while stop_reason == "tool_use":
        for content in response['content']:
            if 'toolUse' in content:
                tool = content['toolUse']

                if tool['name'] == 'GetECSAmisReleases':
                    tool_result = {}
                    
                    release_details = GetECSAmisReleases().execute(tool['input']['image_ids'])
                    tool_result = {
                        "toolUseId": tool['toolUseId'],
                        "content": [{"json": {"release_detail": release_details}}]
                    }
                    
                    tool_result_message = {
                        "role": "user",
                        "content": [
                            {
                                "toolResult": tool_result
                            }
                        ]
                    }
                    # Add the result info to message array
                    messages.append(tool_result_message)
        #Send the messages, including the tool result, to the model.
        stop_reason, response  = stream_messages(
            bedrock_client, model_id, messages, system_text, tool_config,
            stop_sequences=["</result>"])
        # Add response to message history
        messages.append(response)
        
    logger.info("\n##### Report #####")
    click.echo(analysis_response_text.replace("</thinking>",""))
    click.echo(response['content'][0]['text'].replace("<result>",""))
    

if __name__ == '__main__':
    cli()